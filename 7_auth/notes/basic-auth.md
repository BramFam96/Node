# TOC

[Auth time!](#auth-time)

- [TOC](#toc)
- [Concepts, Goals, and Set-up](#concepts-goals-and-set-up)
  - [Concepts](#concepts)
  - [Goals](#goals)
  - [Setup](#setup)
    - [Node Bcrypt](#node-bcrypt)
    - [Methods](#methods)
- [Basic Structure, Authentication](#basic-structure-authentication)
  - [Registration Route](#registration-route)
  - [Basic Authentication- no JWTs](#basic-authentication--no-jwts)

# Concepts, Goals, and Set-up

## Concepts

- authentication
- authorization
- JSON web tokens (JWT)
- API validation
- web-sockets
- testing

## Goals

- Hash some pws with bcrypt!
- Learn about and use JSON web tokens (authentication)
- Use middleware to simplify route security

## Setup

Copied, and stripped the finished demo code:  
[Basic Code](../excercise/app.js)  
Includes basic connection, and a single home route.  
Let's start by adding encryption:

### Node Bcrypt

```js
npm i bcrypt
```

While the underlying logic - the blow fish algorithm is the same, the method naming and implementation differ from Flask.  
To check it out, we'll launch bcrypt in node, without involving express:

```sh
node
const bcrypt = require('bcrypt')
bcrypt ->>
{
  genSaltSync: [Function: genSaltSync],
  genSalt: [Function: genSalt],
  hashSync: [Function: hashSync],
  hash: [Function: hash],
  compareSync: [Function: compareSync],
  compare: [Function: compare],
  getRounds: [Function: getRounds]
}
```

### Methods

We'll be using _genSalt_, _hash_, and _compare_  
**bcrypt.hash(pw-to-hash, work-factor)**  
Let's try it:

```js
node
const bcrypt = require('bcrypt')
bcrypt.hash('test',12) -> Promise(<pending>)
```

# Basic Structure, Authentication

The basic logic for creating and checking pws:

```js
const bcrypt = require('bcrypt')
const pw = 'test';

const hashedPw = bcrypt.hash(pw,12).then(data => console.log(data))
const checkPw = bcrypt.hash(pw,hashedPw).then(data => console.log(data)) -> returns true/false

```

## Registration Route

[route](../excercise/routes/auth.js)

```js
router.post('/register', async (req, res, next) => {
	try {
		//We need to hash pw and save to db
		// Video approach
		/* ######################################################### */
		const { username, password } = req.body
		// Catch missing user or pw ->
		if (!username || !password) {
			throw new ExpressError('Username and password requireed', 400)
		}
		const hashedPw = await bcrypt.hash(password, 12)
		const result = await db.query(
			`INSERT INTO users (username,password) VALUES ($1, $2) RETURNING username`,
			[username, hashedPw]
		)
		// In our previous example, and even flask, we would return an id and store it in session.
		return res.json(result.rows[0])
		/* ########################################################### */
		// If we had an oo approach this logic would be contained in our model. This route could simply be:
		const { username, password } = req.body
		const user = await User.create(username, password)
	} catch (e) {
		// Handle unique key violation -> duplicate usernames
		if (e.code == 23505) {
			throw new ExpressError(
				`Username ${username} already taken. Please choose another.`,
				400
			)
		}
		next(e)
	}
})
```

Unique key violation is an error generated by psql. Psql errors are coded.
Whenever they crop up we'll be checking the code in our catch block.  
_Check the docs for full code list_

## Basic Authentication- no JWTs

- Check if user exists
- if user exists bcrypt.compare the password.
  _Note_ the examples are strange because we did not add ids

```js
router.post('/', async (req,res,next) => {
  try {
    /* ########################################################### */
    const {username, password} = req.body;
    // Catch missing user or pw ->
    if (!username || !password) {
      throw new ExpressError('Username and password requireed',400)
    }
    const result = await db.query(`
    SELECT username, password FROM users WHERE username=$1`,[username]);

    const user = results.rows[0];
    if (user) {
      /* Basic approach
      let loggedIn = await bcrypt.compare()
      */
     if(await bcrypt.compare(password,user.password)){
      return res.json({message: 'Logged in'})
     } else {
      throw new ExpressError('Password invalid',400)
     }
    } else {
      throw new ExpressError('Username not found',400)
    }
  } catch(e){
    next(e)
  }
```

Reversing negatives for better structure:

```js
router.post('/', async (req,res,next) => {
  try {

    const {username, password} = req.body;
  // Handle missing user/password
    if (!username || !password) {
      throw new ExpressError('Username and password required',400)
    }

    const result = await db.query(`
    SELECT username, password FROM users WHERE username=$1`,[username]);

    const user = results.rows[0];

    if (!user) {
      throw new ExpressError('Username not found',400)
    }
    if(!await bcrypt.compare(password,user.password)){
      throw new ExpressError('Password invalid',400)

    return res.json({message: 'Logged in'})

  } catch(e){
    next(e)
  }
```

Again, this would be much cleaner with seperate model logic

